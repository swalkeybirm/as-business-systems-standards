# General PL/SQL Writing Guidance

** To be Updated **

Always rename aggregates and function-wrapped columns:

```sql
SELECT
    name,
    SUM(amount) AS sum_amount
FROM ...
```

Always rename all columns when selecting with table aliases:

```sql
SELECT
    projects.name AS project_name,
    COUNT(backings.id) AS backings_count
FROM 
    ksr.backings AS backings
    INNER JOIN ksr.projects AS projects ON ...
```

Always use `AS` to rename columns:

__GOOD__:

```sql
SELECT
    projects.name AS project_name,
    COUNT(backings.id) AS backings_count
...
```

__BAD__:

```sql
SELECT
    projects.name project_name,
    COUNT(backings.id) backings_count
...
```

Order (`ASC`, `DESC`) should always be explicit. All window functions should be aliased.

---

## `JOIN`

__USE ANSI JOIN SYNTAX!__

Explicitly use `INNER JOIN` not just `JOIN`, making multiple lines of `INNER JOIN`s easier to scan:

__GOOD__:

```sql
SELECT
    projects.name      AS project_name,
    COUNT(backings.id) AS backings_count
FROM 
    ksr.projects AS projects
    INNER JOIN ksr.backings AS backings
    ON ...
    LEFT OUTER JOIN ksr.backer_rewards AS backer_rewards 
    ON ...
    LEFT OUTER JOIN ...
```

__BAD__:

```sql
SELECT
    projects.name      AS project_name,
    COUNT(backings.id) AS backings_count
FROM 
    ksr.projects AS projects
    JOIN ksr.backings AS backings 
    ON ...
    LEFT OUTER JOIN ksr.backer_rewards AS backer_rewards
    ON ...
    LEFT OUTER JOIN ...
```

Additional filters in the `INNER JOIN` go on new indented lines:

```sql
SELECT
    projects.name      AS project_name,
    COUNT(backings.id) AS backings_count
FROM 
    ksr.projects AS projects
    INNER JOIN ksr.backings AS backings
    ON projects.id = backings.project_id
    AND backings.project_country != 'US'
    ...
```

The `ON` keyword and condition goes on a  new line:

```sql
SELECT
    projects.name      AS project_name,
    COUNT(backings.id) AS backings_count
FROM 
    ksr.projects AS projects
    INNER JOIN ksr.backings AS backings 
    ON projects.id = backings.project_id
    ...
```

---

## `WHERE`

Multiple `WHERE` clauses should go on different lines and begin with the SQL operator:

```sql
SELECT
    name,
    goal
FROM 
    ksr.projects AS projects
WHERE
    country = 'US'
    AND TRUNCT(deadline) >= DATE '2015-01-01'
    ...
```

---

## `CASE`

```sql
CASE 
    WHEN category = 'Art' THEN backer_id
    ELSE NULL
END
```

---

## `COMMIT`, `ROLLBACK`

A function or procedure should take a parameter to specify this behavior. This means it can be controlled by the calling code and makes it more flexible.

In your package spec specify constants for commit and rollback:

```sql
g_COMMIT   CONSTANT NUMBER := 1;
g_ROLLBACK CONSTANT NUMBER := -1;
```

Pass this value as a parameter into functions and procedures:

```sql
PROCEDURE get_transactions(i_commit IN NUMBER)
```

It can then be used like this:

```sql
IF p_commit = g_COMMIT THEN
    DSP.line('package.get_transactions', 'Commit');
    COMMIT;
ELSIF p_commit = g_ROLLBACK THEN
    DSP.line('package.get_transactions', 'Rollback');
    ROLLBACK;
END IF;
```

## Triggers

__DO NOT USE TRIGGERS__

## Primary Key Sequences

From Oracle Database 12c use database identity columns to define table sequence columns:

```sql
 CREATE TABLE new_table (
    primary_key_id NUMBER GENERATED BY DEFAULT ON NULL AS IDENTITY,
    ...
);
```

The value in column primary_key_id will be autmoatically generated as an incrementing value. For more information on this visit: [docs.oracle.com](https://docs.oracle.com/en/database/other-databases/nosql-database/22.1/sqlreferencefornosql/identity-column.html)

## Functions and procedures

Speficy functions and procedures appropriately. Do not just make everything a procedure.

## Single responsibility principal

The [Single responsibility principle](https://en.wikipedia.org/wiki/Single_responsibility_principle) - each block of code should do one thing, and one thing well.

## `CASE` expressions

This makes assigning a varable based of a number of options cleaner. Use this method over if-else statements and decode

__GOOD__:

```sql
dept_desc := CASE deptno
    WHEN 10 THEN 'Accounting'
    WHEN 20 THEN 'Research'
    ELSE 'Unknown'
END;
```

__BAD__:

```sql
IF (deptno = 10) THEN
    dept_desc := 'Accounting';
ELSIF (deptno = 20) THEN
    dept_desc := 'Research';
ELSE
    dept_desc := 'Unknown';
END IF;
```

## Packages

* Package names should start with `pkw_`
* Single parameter functions and procedures definitions are written on a single line
* Multiple parameters functions and procedure definitions have parameters separate lines
* All parameters must have a declaration specified: `in`, `out`, `nocopy` and these should align vertically 

```sql
CREATE OR REPLACE PACKAGE pkw_cust_sal 
AS 
    PROCEDURE find_sal(c_id IN student.id%type);
    
    PROCEDURE find_student(
        p_id  IN  student.id%TYPE,
        p_dep OUT student.department%TYPE);
   
   FUNCTION get_sal RETURN NUMBER;
   
   FUNCTION get_student(
       p_id  IN student.id%TYPE,
       p_dep IN student.department%TYPE)
       RETURN t_student;
END pkw_cust_sal;
/

CREATE OR REPLACE PACKAGE BODY pkw_cust_sal
AS
    ...

    ----------------------------------------------------------------------------
    FUNCTION get_student (
      p_id  IN student.id%TYPE,
        p_dep IN student.department%TYPE)
    ----------------------------------------------------------------------------
        RETURN t_student
    AS
        l_stu t_student;
    BEGIN
      ...
    END get_student;

    ...

END pkw_cust_sal;
/
```

## Tips

Your text editor can help you. __DO NOT USE__ Notepad, WordPad or Word. Do use:

* Toad
* SqlDeveloper
* Notepad ++
* Sublime Text
* Ultra Edit
* VS Code
* this list is endless
